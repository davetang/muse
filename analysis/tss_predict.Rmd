---
title: "Sequence composition and Random Forests"
date: "`r Sys.Date()`"
output:
  workflowr::wflow_html:
    toc: true
params:
  span: 2
  host: "https://asia.ensembl.org"
---

```{r setup, include=FALSE}
library(tidyverse)
knitr::opts_chunk$set(echo = TRUE)
httr::set_config(httr::config(ssl_verifypeer = FALSE))
```

## Introduction

Transcriptional starting sites (TSSs) demarcate the first position in the DNA sequence that gets transcribed into RNA. In this work, we will try to build a classifier to try to predict TSSs. We will train our classifier using the NCBI Reference Sequence Database also known as RefSeq.

## Packages

Function for loading required Bioconductor packages (and install them first, if missing).

```{r load_package, message=FALSE, warning=FALSE}
load_package <- function(x, source = "bioc"){
  if(!require(x, character.only = TRUE, quietly = TRUE)){
    if (source == "bioc"){
      BiocManager::install(x, character.only = TRUE)
    } else if (source == "cran"){
      install.packages(x, character.only = TRUE)
    } else {
      stop("Unrecognised source")
    }
    library(x, character.only = TRUE)
  }
}
```

## RefSeq

We will use the Bioconductor package `biomaRt` to download the entire collection of RefSeq sequences.

```{r load_biomart}
load_package('biomaRt')
```

Find the human gene set.

```{r list_datasets}
ensembl <- useMart('ensembl', host = params$host)
biomaRt::listDatasets(ensembl) %>%
  filter(grepl('human', description, TRUE))
```

Find RefSeq attributes.

```{r list_filters}
ensembl <- useMart('ensembl', dataset = 'hsapiens_gene_ensembl', host = params$host)
listAttributes(ensembl) %>%
  filter(grepl('refseq', description, TRUE))
```

Fetch all RefSeq mRNAs on assembled chromosomes.

```{r fetch_refseq_mrna}
my_chr <- c(1:22, 'X', 'Y')

my_refseq <- getBM(
  attributes='refseq_mrna',
  filters = 'chromosome_name',
  values = my_chr,
  mart = ensembl
)
```

Number of RefSeq IDs.

```{r number_refseq_id}
dim(my_refseq)
```

Build table. Note that when working with transcripts, use the attributes `transcript_start` and `transcript_end`, and not the attributes `start_position` and `end_position`; using those will give you the Ensembl gene coordinates and not the RefSeq coordinates, which is what we want! (I have retrieved the Ensembl coordinates for illustrative purposes.)

```{r my_refseq_loci}
my_att <- c(
  'refseq_mrna',
  'chromosome_name',
  'transcript_start',
  'transcript_end',
  'start_position',
  'end_position',
  'strand'
)

my_refseq_loci <- getBM(
  attributes = my_att,
  filters = c('refseq_mrna', 'chromosome_name'),
  values = list(refseq_mrna = my_refseq$refseq_mrna, chromosome_name = my_chr),
  mart = ensembl
)
```

Check out the table.

```{r check_out_refseq_loci}
head(my_refseq_loci)
```

Check for duplicated entries.

```{r dup_refseq}
table(duplicated(my_refseq_loci$refseq_mrna))
```

Removed duplicated entries.

```{r remove_dup}
my_refseq_loci_uniq <- my_refseq_loci[!duplicated(my_refseq_loci$refseq_mrna),]
dim(my_refseq_loci_uniq)
```

We will modify `chromosome_name` and `strand` to make it compatible with `BSgenome.Hsapiens.UCSC.hg38`.

```{r add_chr_and_strand}
my_refseq_loci_uniq %>%
  mutate(strand = ifelse(strand == 1, yes = '+', no = '-')) %>%
  mutate(chromosome_name = sub("^", "chr", chromosome_name)) -> my_refseq_loci_uniq

head(my_refseq_loci_uniq)
```

## Transcription Start Site

The TSS is `transcript_start` when the transcript is on the `+` strand and is `transcript_end` on the `-` strand. We want to retrieve sequence upstream and downstream of the TSS, so we will subtract and add coordinates accordingly.

```{r tss_span}
my_tss <- list()

my_tss$loci <- my_refseq_loci_uniq %>%
  dplyr::select(-c(start_position, end_position)) %>%
  mutate(tss_start = if_else(strand == "+", transcript_start - params$span, transcript_end - params$span)) %>%
  mutate(tss_end = if_else(strand == "+", transcript_start + params$span, transcript_end + params$span))

head(my_tss$loci)
```

## Random loci

Sample a bunch of random sequences in hg38.

```{r load_hg38, message=FALSE, warning=FALSE}
load_package('BSgenome.Hsapiens.UCSC.hg38')
```

Save chromosomes and their sizes.

```{r hg38}
hg38_ref <- seqnames(BSgenome.Hsapiens.UCSC.hg38)
hg38_chr <- hg38_ref[!grepl("_", hg38_ref)]
hg38_chr <- hg38_chr[!grepl("chrM", hg38_chr)]

hg38_chr_size <- sapply(hg38_chr, function(x){
  length(BSgenome.Hsapiens.UCSC.hg38[[x]])
})

head(hg38_chr_size)
```

Sample chromosome based on length of chromosome.

```{r my_random_loci}
set.seed(1984)
n <- nrow(my_tss$loci)
schr <- sample(
  hg38_chr,
  n,
  TRUE,
  prob = hg38_chr_size/sum(hg38_chr_size)
)

sstrand <- sample(c("+", "-"), n, TRUE)
sstart <- sapply(schr, function(x){
  sample(hg38_chr_size[x] - (params$span * 2), 1)
})
send <- sstart + (params$span*2)

my_random <- list()

my_random$loci <- data.frame(
  chr = schr,
  start = sstart,
  end = send,
  strand = sstrand
)

head(my_random$loci)
```

## Removing overlaps

Since some of the randomly sampled regions may overlap/intersect with TSSs, I used the GenomicRanges package to remove these overlapping regions:

```{r load_genomic_ranges}
load_package("GenomicRanges")
```

Create a GRanges object given an object, my_refseq_loci

```{r my_tss_gr}
my_tss$gr <- with(
  my_tss$loci,
  GRanges(chromosome_name,
          IRanges(tss_start, tss_end, names = refseq_mrna),
          strand
  )
)

head(my_tss$gr)
```

Create random GRanges object.

```{r my_random_gr}
my_random$gr <- with(
  my_random$loci,
  GRanges(chr,
          IRanges(start, end, names = paste(chr, start, end, sep = "_")),
          strand
  )
)

head(my_random$gr)
```

Overlap between random regions and TSS's. Note that there are cases where a random region overlaps more than one TSS, which indicates that TSS regions are overlapping.

```{r count_overlaps_gr}
table(countOverlaps(my_random$gr, my_tss$gr))
```

Remove overlapping random sites.

```{r random_loci_no_overlap}
my_random$loci_no <- my_random$loci[countOverlaps(my_random$gr, my_tss$gr) == 0, ]
dim(my_random$loci_no)
```

Check overlapping TSS regions.

```{r count_overlaps_tss}
table(countOverlaps(my_tss$gr, my_tss$gr, minoverlap = 1))
```

Create a set of non-overlapping TSS regions (the conditional is `== 1` because we are comparing regions against itself and 1 is the self overlap), where a TSS does not overlap by a single bp.

```{r tss_loci_no_overlap}
my_tss$loci_no <- my_tss$loci[countOverlaps(my_tss$gr, my_tss$gr, minoverlap = 1) == 1, ]
dim(my_tss$loci_no)
```

## Sequence

Now to fetch the sequences and calculate the dinucleotide frequencies:

```{r random_seq}
my_random$seq <- getSeq(
  BSgenome.Hsapiens.UCSC.hg38,
  names = my_random$loci$chr,
  start = my_random$loci$start,
  end = my_random$loci$end,
  strand = my_random$loci$strand
)

head(my_random$seq)
```

Remove entries with N's.

```{r remove_n}
my_random$seq <- my_random$seq[! grepl("N", my_random$seq)]
head(my_random$seq)
```

Obtain TSS sequences.

```{r tss_seq}
my_tss$seq <- getSeq(
  BSgenome.Hsapiens.UCSC.hg38,
  names = my_tss$loci$chromosome_name,
  start = my_tss$loci$tss_start,
  end = my_tss$loci$tss_end,
  strand = my_tss$loci$strand
)

my_tss$seq <- my_tss$seq[! grepl("N", my_tss$seq)]
head(my_tss$seq)
```

Obtain TSS sequences non-overlapping.

```{r my_tss_seq_non_overlap}
my_tss$seq_no <- getSeq(
  BSgenome.Hsapiens.UCSC.hg38,
  names = my_tss$loci_no$chromosome_name,
  start = my_tss$loci_no$tss_start,
  end = my_tss$loci_no$tss_end,
  strand = my_tss$loci_no$strand
)

my_tss$seq_no <- my_tss$seq_no[! grepl("N", my_tss$seq_no)]
head(my_tss$seq_no)
```

Calculate the di-nucleotide frequency.

```{r di_freq}
my_random$di <- dinucleotideFrequency(my_random$seq)
colSums(my_random$di)

my_tss$di <- dinucleotideFrequency(my_tss$seq)
colSums(my_tss$di)

my_tss$di_no <- dinucleotideFrequency(my_tss$seq_no)
colSums(my_tss$di_no)
```

Plot di-nucleotide frequencies between TSS and random regions.

```{r plot_di}
my_df <- data.frame(
  x = colMeans(my_tss$di),
  y = colMeans(my_random$di),
  di = colnames(my_tss$di)
)

ggplot(my_df, aes(x, y, label = di)) +
  geom_point() +
  geom_text(nudge_x = 0.005) +
  geom_abline(slope = 1, lty = 3) +
  labs(x = "TSS", y = "Random") +
  theme_bw()
```

Plot di-nucleotide frequencies between overlapping and non-overlapping TSS regions.

```{r plot_di_tss}
my_df <- data.frame(
  x = colMeans(my_tss$di),
  y = colMeans(my_tss$di_no),
  di = colnames(my_tss$di)
)

ggplot(my_df, aes(x, y, label = di)) +
  geom_point() +
  geom_text(nudge_x = 0.005) +
  geom_abline(slope = 1, lty = 3) +
  labs(x = "TSS", y = "TSS no overlap") +
  theme_bw()
```

## Random Forests

Use Random Forests to train a predictor using the TSSs and random di-nucleotide frequencies.

```{r load_random_forest, message=FALSE, warning=FALSE}
load_package('randomForest', source = "cran")
```

Combine TSS and random data.

```{r create_my_data}
as.data.frame(my_tss$di) %>%
  mutate(class = 'tss') -> my_data

as.data.frame(my_random$di) %>%
  mutate(class = 'random') %>%
  rbind(my_data) %>%
  mutate(class = factor(class)) -> my_data

dim(my_data)
```

Split 80/20.

```{r train_and_test_data}
set.seed(1984)
idx <- sample(nrow(my_data), nrow(my_data)*0.8)

train <- my_data[idx, ]
test <- my_data[-idx, ]

dim(train)
dim(test)
```

Train Random Forest.

```{r random_forest}
my_rf <- randomForest(
  class ~ .,
  data = train,
  importance = TRUE,
  do.trace = 100,
  ntree = 200
)

my_rf
```

Feature importance.

```{r importance}
rn <- round(importance(my_rf), 2)
rn[order(rn[,3], decreasing=TRUE),]
```

As a plot.

```{r importance_plot}
varImpPlot(my_rf)
```

Predict.

```{r predict}
data.predict <- predict(my_rf, test)
prop.table(table(observed = test$class, predict = data.predict), 1)
```

Use `pROC` package to get area under curve.

```{r load_proc, message=FALSE, warning=FALSE}
load_package("pROC", source = "cran")
```

Check ROC.

```{r roc}
roc(my_rf$y, my_rf$votes[, 'random'])
```

Plot ROC with the `verification` package.

```{r load_verification, message=FALSE, warning=FALSE}
load_package('verification', source = "cran")
```

Plot ROC.

```{r plot_roc}
aucc <- roc.area(as.integer(train$class=='tss'), my_rf$votes[,2])$A
roc.plot(as.integer(train$class=='tss'), my_rf$votes[,2], main="")
legend("bottomright", bty="n", sprintf("Area Under the Curve (AUC) = %1.3f", aucc))
title(main="OOB ROC Curve Random Forest for predicting TSS")
```

### Nucleotide frequency across TSS

The `nucleotideFrequencyAt` function will return the single nucleotide frequency at a specific location.

```{r nuc_freq_at}
nucleotideFrequencyAt(my_tss$seq, 3)
```

Use `sapply` to calculate at all sites.

There is a higher CT (pyrimidine) ratio one position before the TSS (second column) and a higher AG (purine) ratio at the TSS (third column) forming the classic pyrimidineâ€“purine (PyPu) di-nucleotide at a TSS.

```{r nuc_freq_at_all}
nuc_freq <- sapply(1:((params$span*2)+1), function(x) nucleotideFrequencyAt(my_tss$seq, x))
apply(nuc_freq, 2, function(x) x/sum(x))
```

Calculate di-nucleotide frequencies at all sites.

```{r dinuc_freq}
dinuc_freq_tss <- lapply(1:(params$span*2), function(x){
  dinucleotideFrequency(subseq(my_tss$seq, x, x+1))
})

dinuc_freq_random <- lapply(1:(params$span*2), function(x){
  dinucleotideFrequency(subseq(my_random$seq, x, x+1))
})

dinuc_freq_tss_df <- do.call(cbind.data.frame, dinuc_freq_tss)
dinuc_freq_random_df <- do.call(cbind.data.frame, dinuc_freq_random)

my_colname <- paste0(
  'X',
  rep(1:(params$span*2), each = 16),
  "_",
  colnames(dinuc_freq_tss_df)[1:16]
)

colnames(dinuc_freq_tss_df) <- my_colname
colnames(dinuc_freq_random_df) <- my_colname

head(dinuc_freq_tss_df)
```

Combine TSS and random data.

```{r create_my_data2}
dinuc_freq_tss_df %>%
  mutate(class = 'tss') -> my_data2

dinuc_freq_random_df %>%
  mutate(class = 'random') %>%
  rbind(my_data2) %>%
  mutate(class = factor(class)) -> my_data2

dim(my_data2)
```

Split 80/20.

```{r train_and_test_data2}
set.seed(1984)
idx <- sample(nrow(my_data2), nrow(my_data2)*0.8)

train2 <- my_data2[idx, ]
test2 <- my_data2[-idx, ]

dim(train2)
dim(test2)
```

Train Random Forest.

```{r random_forest2}
my_rf2 <- randomForest(
  class ~ .,
  data = train2,
  importance = TRUE,
  do.trace = 100,
  ntree = 200
)

my_rf2
```

Feature importance.

```{r importance2}
rn2 <- round(importance(my_rf2), 2)
head(rn2[order(rn2[,3], decreasing=TRUE),])
```

As a plot.

```{r importance_plot2, fig.height=8, fig.width=5}
varImpPlot(my_rf2)
```

Compare prediction results of our first model and our second model.

```{r predict2}
# results from first model
data.predict <- predict(my_rf, test)
prop.table(table(observed = test$class, predict = data.predict), 1)

# results from second model
data.predict2 <- predict(my_rf2, test2)
prop.table(table(observed = test2$class, predict = data.predict2), 1)
```

By including the positional information of the di-nucleotides, we have a better TSS classifier, which makes sense since not all the bases upstream and downstream of the TSS have a nucleotide preference and thus were diluting the signal in our first model where we calculated the overall di-nucleotide frequency.
