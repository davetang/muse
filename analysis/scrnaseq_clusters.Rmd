---
title: "scRNA-seq clusters"
date: "`r Sys.Date()`"
output:
  workflowr::wflow_html:
    toc: true
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
suppressPackageStartupMessages({
  library(tidyverse)
  library(Seurat)
  library(cluster)
  library(pheatmap)
})
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction

Assess the heterogeneity in scRNA-seq clusters where heterogeneity refers to how variable or diverse cells are within a given cluster. High heterogeneity means cells in that cluster are quite different from each other, while low heterogeneity means they're very similar.

## Dependencies

```{r install, eval=FALSE}
install.packages(c("Seurat", "cluster", "pheatmap"))
```

## Seurat workflow

Import raw pbmc3k dataset from my server.

```{r seurat_obj_raw}
seurat_obj <- readRDS(url("https://davetang.org/file/pbmc3k_seurat.rds", "rb"))
seurat_obj
```

Filter.

```{r seurat_obj}
seurat_obj <- CreateSeuratObject(
  counts = seurat_obj@assays$RNA$counts,
  min.cells = 3,
  min.features = 200,
  project = "pbmc3k"
)
seurat_obj
```

Process with the Seurat 4 workflow.

```{r pbmc3k_v4}
seurat_wf_v4 <- function(seurat_obj, scale_factor = 1e4, num_features = 2000, num_pcs = 30, cluster_res = 0.5, debug_flag = FALSE){
  
  seurat_obj <- NormalizeData(seurat_obj, normalization.method = "LogNormalize", scale.factor = scale_factor, verbose = debug_flag)
  seurat_obj <- FindVariableFeatures(seurat_obj, selection.method = 'vst', nfeatures = num_features, verbose = debug_flag)
  seurat_obj <- ScaleData(seurat_obj, verbose = debug_flag)
  seurat_obj <- RunPCA(seurat_obj, verbose = debug_flag)
  seurat_obj <- RunUMAP(seurat_obj, dims = 1:num_pcs, verbose = debug_flag)
  seurat_obj <- FindNeighbors(seurat_obj, dims = 1:num_pcs, verbose = debug_flag)
  seurat_obj <- FindClusters(seurat_obj, resolution = cluster_res, verbose = debug_flag)
  
  seurat_obj
}

seurat_obj <- seurat_wf_v4(seurat_obj)
```

## Clusters

Cluster results are in `seurat_clusters`.

```{r seurat_clusters}
table(seurat_obj$seurat_clusters)
```

## Silhouette Scores

* **What it measures:** How similar each cell is to cells in its own cluster compared to cells in other clusters.

* **Interpretation:** 
    * Score close to **1** = cell is very similar to its cluster and different from others (good clustering, low heterogeneity)
    * Score close to **0** = cell is on the border between clusters
    * Score close to **-1** = cell might be in the wrong cluster

* **Why it matters:** Higher average silhouette scores for a cluster indicate it's well-separated and homogeneous.

The function `cluster::silhouette()` computes silhouette information according to a given clustering in k clusters.

> silhouette(x, dist, dmatrix, ...)

where `x` is an object of appropriate class; for the default method an integer vector with $k$ different integer cluster codes or a list with such an `x$clustering` component.

```{r sil_score}
pca_embeddings <- Seurat::Embeddings(seurat_obj, reduction = "pca")[, 1:30]
dist_matrix <- stats::dist(pca_embeddings)
clusters <- seurat_obj$seurat_clusters
cluster_numeric <- as.numeric(clusters)
sil_scores <- cluster::silhouette(cluster_numeric, dist_matrix)

head(sil_scores)
```

Calculate average silhouette width per cluster.
Note: `silhouette()` uses numeric cluster codes (1, 2, 3, ...) internally, which correspond to factor levels. Since Seurat clusters are 0-indexed (0, 1, 2, ...), we need to map back to the original labels.

```{r sil_summary}
# Get the mapping from numeric codes to original cluster labels
cluster_levels <- levels(clusters)

sil_scores |>
  as.data.frame() |>
  dplyr::summarise(avg_silhouette = mean(sil_width), .by = 'cluster') |>
  dplyr::arrange(-avg_silhouette) |>
  dplyr::mutate(cluster = factor(cluster_levels[cluster], levels = cluster_levels)) -> sil_summary

sil_summary |> dplyr::arrange(-avg_silhouette)
```

Plot silhouette scores.

```{r sil_summary_plot}
ggplot(sil_summary, aes(x = reorder(cluster, avg_silhouette), y = avg_silhouette, fill = cluster)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  labs(title = "Cluster Quality: Silhouette Scores",
                subtitle = "Higher scores = more distinct/homogeneous clusters",
                x = "Cluster", y = "Average Silhouette Width") +
  theme_minimal() +
  theme(legend.position = "none")
```

Higher scores = more distinct/homogeneous clusters means two things:

* Distinct (well-separated from other clusters): Cells in this cluster are far away from cells in other clusters.
* Homogeneous (internally similar): Cells within this cluster are close to each other.

The silhouette score combines both concepts:

* It measures how similar a cell is to its own cluster (homogeneity)
* Compared to how similar it is to the nearest neighboring cluster (distinctness/separation)

For example a high silhouette score (e.g., 0.8) means cells in cluster A are tightly packed together AND far from cluster B -> cluster A is both homogeneous internally and well-separated from others. A low silhouette score (e.g., 0.2) means cells in cluster A are either spread out OR very close to cluster B (or both) -> poor clustering quality.

It is important to note that a cluster can have a high silhouette score for two reasons:

* Low heterogeneity (cells are very similar to each other).
* Good separation from other clusters.

## Within-Cluster Variance and Coefficient of Variation

* **What it measures:** How much gene expression varies among cells within each cluster.

* **Interpretation:**
    * **Variance** = absolute spread of expression values
    * **Coefficient of Variation (CV)** = variance relative to mean (more comparable across genes)
    * Higher values = more heterogeneous gene expression within the cluster

* **Why it matters:** Some cell types naturally have more variable expression (e.g., transitioning cells) while others are more stable (e.g., terminally differentiated cells).

```{r variance}
expr_data <- Seurat::GetAssayData(seurat_obj, assay = 'RNA', layer = "data")

variable_genes <- Seurat::VariableFeatures(seurat_obj)
expr_data <- expr_data[variable_genes, ]

# Calculate variance and CV for each cluster
variance_results <- lapply(unique(clusters), function(cl) {
  # Get cells in this cluster
  cells_in_cluster <- which(clusters == cl)
  cluster_expr <- expr_data[, cells_in_cluster]
  
  # Calculate metrics for each gene
  gene_means <- apply(cluster_expr, 1, mean)
  gene_vars <- apply(cluster_expr, 1, var)
  gene_cv <- sqrt(gene_vars) / (gene_means + 0.01)  # Add small constant to avoid division by zero
  
  data.frame(
    cluster = cl,
    mean_variance = mean(gene_vars),
    mean_cv = mean(gene_cv),
    median_variance = median(gene_vars),
    median_cv = median(gene_cv)
  )
}) |> dplyr::bind_rows()

variance_results |>
  dplyr::arrange(-mean_cv)
```

Plot.

```{r variance_plot}
ggplot(variance_results, ggplot2::aes(x = reorder(cluster, mean_cv), 
                                      y = mean_cv, fill = cluster)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  labs(title = "Within-Cluster Gene Expression Variability",
       subtitle = "Higher CV = more heterogeneous expression patterns",
       x = "Cluster", y = "Mean Coefficient of Variation") +
  theme_minimal() +
  theme(legend.position = "none")
```

CV (Coefficient of Variation) measures how variable gene expression is relative to the average expression level. A low CV (e.g., 0.3 or 30%): Gene expression values are tightly clustered around the mean; a high CV (e.g., 1.5 or 150%): Gene expression values are spread widely around the mean. CV is normalised by the mean, so it's comparable across genes with different expression levels.

* High mean CV across genes: Cells in this cluster have diverse transcriptional states - they're expressing different genes at different levels
* Low mean CV across genes: Cells in this cluster have consistent transcriptional states - they're expressing genes at similar levels

### WSS and BSS

Within-cluster sum of squares (WSS) and Between-cluster sum of squares (BSS).

```{r wss_and_bss}
pca_embeddings <- Seurat::Embeddings(seurat_obj, reduction = "pca")[, 1:30]
clusters <- seurat_obj$seurat_clusters

# Calculate overall centroid (mean of all cells)
overall_centroid <- colMeans(pca_embeddings)

total_wss <- 0
total_bss <- 0

# Calculate for each cluster
for (cl in unique(clusters)) {
  # Get cells in this cluster
  cells_in_cluster <- which(clusters == cl)
  cluster_data <- pca_embeddings[cells_in_cluster, ]
  
  # Cluster centroid
  cluster_centroid <- colMeans(cluster_data)
  
  # Within-cluster sum of squares (WSS)
  wss <- sum(apply(cluster_data, 1, function(x) sum((x - cluster_centroid)^2)))
  total_wss <- total_wss + wss
  
  # Between-cluster sum of squares (BSS)
  n_cells <- nrow(cluster_data)
  bss <- n_cells * sum((cluster_centroid - overall_centroid)^2)
  total_bss <- total_bss + bss
}

cat("Within-Cluster Sum of Squares (WSS):", round(total_wss, 2), "\n")
cat("Between-Cluster Sum of Squares (BSS):", round(total_bss, 2), "\n")
cat("Total Sum of Squares (TSS):", round(total_wss + total_bss, 2), "\n")
cat("BSS/TSS Ratio:", round(total_bss / (total_wss + total_bss), 4), 
    "(higher is better, closer to 1 = better clustering)\n")
```

Typically, the WSS and BSS are compared across different clustering results; the goal is to:

* Minimise WSS (tight, homogeneous clusters).
* Maximise BSS (well-separated clusters).
* Maximise BSS/TSS (clustering explains most of the variation).


## Intra-Cluster Distances in PCA Space

* **What it measures:** The average distance between cells within the same cluster in reduced dimension space.

* **Interpretation:**
    * **Smaller distances** = cells are tightly clustered together (low heterogeneity)
    * **Larger distances** = cells are spread out (high heterogeneity)

* **Why it matters:** This gives you a spatial sense of cluster compactness. We calculate this in PCA space because PCA preserves meaningful distances (Euclidean distances relate to expression differences). UMAP distances are **not** meaningful for quantitative comparisons because UMAP distorts distances to optimise for visualisation - nearby points in UMAP may not be truly similar, and distant points may not be truly different.

```{r distances_pca}
# Function to calculate intra-cluster distances
calc_intra_cluster_dist <- function(embeddings, labels) {
  results <- lapply(unique(labels), function(cl) {
    # Get cells in this cluster
    cells_in_cluster <- which(labels == cl)
    cluster_embeddings <- embeddings[cells_in_cluster, ]
    
    # Calculate all pairwise distances within cluster
    dist_within <- stats::dist(cluster_embeddings)
    
    data.frame(
      cluster = cl,
      n_cells = length(cells_in_cluster),
      mean_distance = mean(dist_within),
      median_distance = median(dist_within),
      sd_distance = sd(dist_within)
    )
  }) |> dplyr::bind_rows()
  
  return(results)
}

pca_embeddings <- Seurat::Embeddings(seurat_obj, reduction = "pca")[, 1:30]
pca_dist_summary <- calc_intra_cluster_dist(pca_embeddings, clusters)

pca_dist_summary |>
  dplyr::arrange(desc(mean_distance))
```

Plot.

```{r distances_plot}
ggplot(pca_dist_summary, aes(x = reorder(cluster, mean_distance), 
                             y = mean_distance, fill = cluster)) +
  geom_bar(stat = "identity") +
  geom_errorbar(ggplot2::aes(ymin = mean_distance - sd_distance, 
                             ymax = mean_distance + sd_distance), 
                width = 0.2) +
  coord_flip() +
  labs(title = "Cluster Spread in PCA Space",
       subtitle = "Higher distance = more spread out cells = higher heterogeneity",
       x = "Cluster", y = "Mean Pairwise Distance") +
  theme_minimal() +
  theme(legend.position = "none")
```

## Shannon Entropy

* **What it measures:** The diversity of gene expression distributions within each cluster.

* **Interpretation:**
    * **Higher entropy** = gene expression is more evenly distributed across many values (high heterogeneity)
    * **Lower entropy** = gene expression is concentrated around specific values (low heterogeneity)

* **Why it matters:** Entropy captures whether cells have uniform or variable transcriptional states. It's particularly useful for identifying transitional or stressed cell populations.

```{r entropy}
shannon_entropy <- function(x) {
  # Handle edge case: if all values are identical, entropy is 0
  if (length(unique(x)) == 1 || (max(x) - min(x)) < 1e-10) {
    return(0)
  }


  # Bin expression values into 10 bins
  breaks <- seq(min(x), max(x), length.out = 11)
  hist_data <- hist(x, breaks = breaks, plot = FALSE)

  # Calculate probability of each bin
  probs <- hist_data$counts / sum(hist_data$counts)
  probs <- probs[probs > 0]  # Remove zeros to avoid log(0)

  # Shannon entropy formula: -sum(p * log2(p))
  return(-sum(probs * log2(probs)))
}

entropy_results <- lapply(unique(clusters), function(cl) {
  # Get cells in this cluster
  cells_in_cluster <- which(clusters == cl)
  cluster_expr <- expr_data[, cells_in_cluster]
  
  # Calculate entropy for each gene
  gene_entropies <- apply(cluster_expr, 1, shannon_entropy)
  
  data.frame(
    cluster = cl,
    mean_entropy = mean(gene_entropies),
    median_entropy = median(gene_entropies),
    sd_entropy = sd(gene_entropies)
  )
}) |> dplyr::bind_rows()

entropy_results |>
  dplyr::arrange(desc(mean_entropy))
```

Plot.

```{r entropy_plot}
ggplot(entropy_results, aes(x = reorder(cluster, mean_entropy), 
                            y = mean_entropy, fill = cluster)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  labs(title = "Expression Distribution Diversity",
       subtitle = "Higher entropy = more diverse/heterogeneous expression patterns",
       x = "Cluster", y = "Mean Shannon Entropy") +
  theme_minimal() +
  theme(legend.position = "none")
```

## Cluster Compactness Metrics

* **What it measures:** How tightly packed a cluster is relative to how far it is from other clusters.

* **Interpretation:**
    * **Lower compactness ratio** = cluster is tight and well-separated (low heterogeneity, good clustering)
    * **Higher compactness ratio** = cluster is spread out or close to other clusters (high heterogeneity or poor separation)

* **Why it matters:** This metric combines within-cluster spread with between-cluster separation, giving you a sense of both heterogeneity and cluster quality.

Calculate centroid (average position) for each cluster and plot the centroids.

```{r centroids}
centroids <- do.call(rbind, lapply(unique(clusters), function(cl) {
  cells_in_cluster <- which(clusters == cl)
  colMeans(pca_embeddings[cells_in_cluster, ])
}))
rownames(centroids) <- unique(clusters)

centroids |>
  as.data.frame() |>
  dplyr::select(PC_1, PC_2) |>
  tibble::rownames_to_column('cluster') -> centroids_1_2

DimPlot(seurat_obj, reduction = 'pca') +
  geom_text(data = centroids_1_2, aes(PC_1, PC_2, label=cluster))
```

Calculate compactness metrics for each cluster.

```{r compactness}
compactness_results <- lapply(unique(clusters), function(cl) {
  # Get cells in this cluster
  cells_in_cluster <- which(clusters == cl)
  cluster_embeddings <- pca_embeddings[cells_in_cluster, ]
  centroid <- centroids[as.character(cl), ]
  
  # Average distance from each cell to its cluster centroid
  distances_to_centroid <- sqrt(apply(cluster_embeddings, 1, function(x) {
    sum((x - centroid)^2)
  }))
  avg_dist_to_centroid <- mean(distances_to_centroid)
  
  # Find distance to nearest other cluster centroid
  other_centroids <- centroids[rownames(centroids) != as.character(cl), , drop = FALSE]
  distances_to_others <- sqrt(apply(other_centroids, 1, function(x) {
    sum((x - centroid)^2)
  }))
  min_dist_to_other <- min(distances_to_others)
  
  # Compactness ratio: within-cluster spread / between-cluster separation
  # Lower is better (tight cluster, well separated)
  compactness_ratio <- avg_dist_to_centroid / min_dist_to_other
  
  data.frame(
    cluster = cl,
    avg_dist_to_centroid = avg_dist_to_centroid,
    min_dist_to_other_cluster = min_dist_to_other,
    compactness_ratio = compactness_ratio
  )
}) |> dplyr::bind_rows()

compactness_results |>
  dplyr::arrange(compactness_ratio)
```

Plot.

```{r compactness_plot}
ggplot(compactness_results, aes(x = reorder(cluster, -compactness_ratio), 
                                y = compactness_ratio, fill = cluster)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  labs(title = "Cluster Compactness Ratio",
       subtitle = "Lower ratio = more compact cluster = lower heterogeneity",
       x = "Cluster", y = "Compactness Ratio") +
  theme_minimal() +
  theme(legend.position = "none")
```

## Comparing Metrics

Combine all metrics into one table.

```{r summary}
summary_comparison <- sil_summary |>
  dplyr::left_join(variance_results, by = "cluster") |>
  dplyr::left_join(pca_dist_summary |> dplyr::select(cluster, mean_distance), 
                   by = "cluster") |>
  dplyr::left_join(entropy_results |> dplyr::select(cluster, mean_entropy), 
                   by = "cluster") |>
  dplyr::left_join(compactness_results |> dplyr::select(cluster, compactness_ratio), 
                   by = "cluster")

summary_comparison <- summary_comparison |>
  dplyr::select(cluster, avg_silhouette, mean_cv, mean_distance, mean_entropy, compactness_ratio)

summary_comparison
```

As a heatmap.

**Important:** The metrics have different directions:

| Metric | High value means | Low value means |
|--------|------------------|-----------------|
| `avg_silhouette` | Good separation, low heterogeneity | Poor separation, high heterogeneity |
| `mean_cv` | High heterogeneity | Low heterogeneity |
| `mean_distance` | High heterogeneity (spread out) | Low heterogeneity (compact) |
| `mean_entropy` | High heterogeneity | Low heterogeneity |
| `compactness_ratio` | Poor compactness, high heterogeneity | Good compactness, low heterogeneity |

So `avg_silhouette` is the only metric where higher = better/more homogeneous. For all others, higher = more heterogeneous.

```{r summary_heatmap}
summary_comparison |>
  tibble::column_to_rownames('cluster') |>
  as.matrix() |>
  pheatmap(scale = "column",
           main = "Cluster Heterogeneity Metrics (column-scaled)")
```

To make comparison easier, we can invert silhouette so all metrics point in the same direction (higher = more heterogeneous):

```{r summary_heatmap_inverted}
summary_inverted <- summary_comparison |>
  dplyr::mutate(
    neg_silhouette = -avg_silhouette  # Invert so higher = worse
  ) |>
  dplyr::select(cluster, neg_silhouette, mean_cv, mean_distance, mean_entropy, compactness_ratio)

summary_inverted |>
  tibble::column_to_rownames('cluster') |>
  as.matrix() |>
  pheatmap(scale = "column",
           main = "Cluster Heterogeneity (all metrics: higher = more heterogeneous)")
```

## Correlation Between Metrics

It's useful to see how these metrics relate to each other:

```{r metric_correlation}
cor_matrix <- summary_comparison |>
  tibble::column_to_rownames('cluster') |>
  cor(method = "spearman")

pheatmap(cor_matrix,
         display_numbers = TRUE,
         number_format = "%.2f",
         main = "Spearman Correlation Between Metrics")
```

Metrics that are highly correlated capture similar aspects of heterogeneity. Metrics with low correlation provide complementary information.

## Interpretation Guide

Each metric captures a different aspect of heterogeneity:

1. **Silhouette scores**: Overall cluster quality and separation
   - Best for: Identifying poorly defined or overlapping clusters

2. **Coefficient of Variation (CV)**: Gene expression variability
   - Best for: Understanding transcriptional diversity within cell types

3. **Intra-cluster distances**: Spatial spread in reduced dimensions
   - Best for: Visual/geometric sense of cluster compactness

4. **Shannon entropy**: Distribution diversity of expression values
   - Best for: Detecting transitional states or stressed populations

5. **Compactness ratio**: Spread relative to cluster separation
   - Best for: Combined measure of internal heterogeneity and cluster quality

## Metrics to measure heterogeneity

* Within-cluster variance/CV
    * Directly measures transcriptional diversity
    * Higher = more heterogeneous gene expression
* Cluster diameter
    * How spread out cells are within cluster
    * Higher = more heterogeneous
* Average within-cluster distance
    * Mean distance between cells in same cluster
    * Higher = more heterogeneous
* Shannon entropy
    * Distribution diversity of gene expression
    * Higher = more heterogeneous

## Biological Interpretation

High heterogeneity in a cluster may indicate:

1. **Transitional cell states**: Cells in the process of differentiating often show high variability as they transition between stable states
2. **Cell cycle effects**: Proliferating cells may cluster together but show heterogeneity due to different cell cycle phases
3. **Technical artifacts**: Batch effects, doublets, or low-quality cells can artificially increase heterogeneity
4. **Over-clustering**: A single biological population split into multiple clusters will appear heterogeneous
5. **Under-clustering**: Multiple distinct populations merged into one cluster
6. **Activation states**: Immune cells responding to stimuli may show high heterogeneity within the same cell type

Low heterogeneity typically indicates:

1. **Well-defined cell types**: Terminally differentiated cells with stable transcriptional programs
2. **Technical over-clustering**: The clustering algorithm may have split a homogeneous population
3. **Small cluster size**: Be cautious interpreting metrics for clusters with very few cells

## Caveats and Limitations

1. **Cluster size affects metrics**: Larger clusters tend to have higher within-cluster distances simply due to having more cells. Consider normalising or using size-matched comparisons.

2. **Gene selection matters**: We calculated CV and entropy on variable genes. Using all genes or marker genes may give different results.

3. **Dimensionality**: PCA-based metrics depend on the number of PCs used. We used 30 PCs, but this choice affects the results.

4. **Resolution dependency**: These metrics depend on clustering resolution. Different resolutions will give different heterogeneity patterns.

5. **Biological vs technical heterogeneity**: These metrics cannot distinguish biological heterogeneity (interesting) from technical noise (not interesting).

```{r cluster_size_check}
# Check if metrics correlate with cluster size
cluster_sizes <- table(clusters)
size_df <- data.frame(
  cluster = names(cluster_sizes),
  n_cells = as.numeric(cluster_sizes)
)

summary_with_size <- summary_comparison |>
  dplyr::left_join(size_df, by = "cluster")

cat("Correlation of metrics with cluster size:\n")
cat("  mean_distance vs n_cells:",
    round(cor(summary_with_size$mean_distance, summary_with_size$n_cells, method = "spearman"), 3), "\n")
cat("  mean_cv vs n_cells:",
    round(cor(summary_with_size$mean_cv, summary_with_size$n_cells, method = "spearman"), 3), "\n")
cat("  avg_silhouette vs n_cells:",
    round(cor(summary_with_size$avg_silhouette, summary_with_size$n_cells, method = "spearman"), 3), "\n")
```

If metrics strongly correlate with cluster size, interpret with caution.

