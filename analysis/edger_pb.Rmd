---
title: "4.10 Single cell RNA-seq differential expression with pseudobulking"
date: "`r Sys.Date()`"
output:
  workflowr::wflow_html:
    toc: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# https://stackoverflow.com/questions/30237310/setting-work-directory-in-knitr-using-opts-chunksetroot-dir-doesnt-wor
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
```

```{r load_libraries, include=FALSE}
suppressPackageStartupMessages({
  library(tidyverse)
  library(edgeR)
  library(Seurat)
  library(pheatmap)
})

options(mc.cores = 8)
```

```{r start_time, include=FALSE}
start_time <- Sys.time()
```

## Introduction

Performing differential expression (DE) analysis on scRNA-seq data presents unique challenges with the primary problem being that individual cells exhibit high variability.

**Pseudobulking** tries to address the issue of variability by aggregating counts from cells that share the same biological replicate (e.g., donor/sample) and cell type. This approach:

1. Reduces technical noise by averaging across many cells.
2. Properly accounts for biological replication at the sample level.
3. Allows the use of well-established bulk RNA-seq DE methods (e.g., edgeR) that have robust statistical frameworks.

This notebook demonstrates how to perform pseudobulk differential expression analysis using edgeR, following the workflow described in [Section 4.10 of the edgeR User's Guide](https://www.bioconductor.org/packages/release/bioc/vignettes/edgeR/inst/doc/edgeRUsersGuide.pdf).

## Data

The single cell RNA-seq data used in this notebook is from the human breast single cell RNA atlas generated by Pal et al. The preprocessing of the data and the complete bioinformatics analyses of the entire atlas study are described in detail in Chen et al. Most of the single cell analysis, such as dimensionality reduction and integration, were performed using Seurat. All the generated Seurat objects are publicly available on [Figshare](https://doi.org/10.6084/m9.figshare.17058077).

The Seurat object used in this notebook was downloaded directly from the website of the edgeR maintainers. This object contains breast tissue micro-environment samples from 13 individual healthy donors. This object has been subsetted to contain 10,000 cells of the total 24,751 cells from the original object.

```{r so}
so <- readRDS("data/SeuratObj.rds")
so
```

Distribution of cell counts across 13 healthy donors and 7 clusters; note that some samples don't have cells belonging to a certain cluster.

```{r group_versus_cluster}
table(so@meta.data$group, so@meta.data$seurat_clusters)
```

## Pseudobulking

Pseudo-bulk samples are created by aggregating read counts together for all the cells with the same combination of human donor and cluster. Here, we generate pseudo-bulk expression profiles from the Seurat object using the `Seurat2PB()` function. The human donor and cell cluster information of the integrated single cell data is stored in the `group` and `seurat_clusters` columns of the `meta.data` component of the Seurat object.

```{r y}
y <- Seurat2PB(so, sample="group", cluster="seurat_clusters")
dim(y$samples)
sum(table(so@meta.data$group, so@meta.data$seurat_clusters) > 0)
```

Counts are aggregated into samples + clusters; note that there aren't 13 * 7 samples because as we noted in the table, some combinations have 0 counts.

```{r y_counts}
colnames(y$counts)
```

The total UMI counts per pseudobulk sample vary considerably, reflecting differences in the number of cells aggregated and their sequencing depth. Importantly, the minimum is greater than zero, confirming that all sample-cluster combinations retained after aggregation contain actual expression data.

```{r y_counts_sum}
summary(colSums(y$counts))
```

## Filtering and normalisation

Before differential expression analysis, we apply two filtering steps to remove low-quality data that could compromise statistical inference.

### Sample filtering

Pseudobulk samples with very few total counts are unreliable because they may represent too few cells or low-quality aggregations. We remove samples with fewer than 50,000 total UMI counts.

```{r filter_samples}
keep.samples <- y$samples$lib.size > 5e4
y <- y[, keep.samples]

dim(y$samples)
```

### Gene filtering

Genes with very low counts across samples provide little statistical information and can adversely affect the multiple testing correction. The `filterByExpr()` function implements edgeR's recommended filtering strategy: it keeps genes that have sufficiently large counts to be statistically meaningful in at least some samples. By default, it requires a gene to have at least 10 counts (`min.count = 10`) in a minimum number of samples (determined by the smallest group size).

```{r filter_genes}
keep.genes <- filterByExpr(y, group=y$samples$cluster)
y <- y[keep.genes, , keep=FALSE]
```

### TMM normalisation

Trimmed Mean of M-values (TMM) normalisation corrects for compositional biases between samples. This is important because differences in library size alone don't account for situations where a few highly-expressed genes consume a disproportionate share of sequencing reads, making other genes appear artificially down-regulated. TMM calculates scaling factors that adjust for these composition effects.

```{r tmm}
y <- normLibSizes(y)
```

## Design matrix

To perform differential expression analysis between cell clusters, we create a design matrix that models both the biological effect of interest (cluster identity) and a blocking factor (donor). Including donor in the model accounts for individual-to-individual variation, ensuring that detected cluster differences are not confounded by donor-specific effects.

The formula `~ cluster + donor` creates an additive model where:

* **cluster** captures the differences between cell types (what we are interested in).
* **donor** accounts for baseline expression differences between individuals (a "nuisance" variable, as some people call it, we want to control for).

```{r design}
donor <- factor(y$samples$sample)
cluster <- as.factor(y$samples$cluster)
design <- model.matrix(~ cluster + donor)
colnames(design) <- gsub("donor", "", colnames(design))
colnames(design)[1] <- "Int"
dim(design)
```

The design matrix has 19 columns: 1 (intercept) + 6 (cluster coefficients, with cluster 0 as reference) + 12 (donor coefficients, with the first donor as reference) = 19 parameters to estimate. Each column represents one model coefficient.

The 59 rows correspond to the 59 pseudobulk samples (unique sample-cluster combinations that passed filtering).

```{r design_head}
head(design)
```

In the design matrix above, the first row represents a sample from cluster 0 and donor `N_0019_total`. It shows `Int=1` (the intercept) with all other coefficients as 0 because both the cluster and donor for this sample are the reference levels. Subsequent rows have 1s in the appropriate cluster and donor columns to indicate which combination each pseudobulk sample represents.

## Dispersion estimation and model fitting

RNA-seq count data exhibits overdispersion (variance exceeds the mean), which the negative binomial distribution models through a dispersion parameter. edgeR estimates dispersion using an empirical Bayes approach that shares information across genes, improving estimates especially when sample sizes are small.

The `robust=TRUE` option protects against outlier genes that might otherwise inflate dispersion estimates. The quasi-likelihood framework (`glmQLFit`) adds an additional layer of variance modelling that accounts for gene-specific variability beyond the negative binomial assumption, providing more reliable statistical inference.

```{r disp}
y <- estimateDisp(y, design, robust=TRUE)
fit <- glmQLFit(y, design, robust=TRUE)
```

## Contrast matrix for cluster comparisons

To identify marker genes for each cell cluster, we compare each cluster against all other clusters combined. This "one versus rest" approach reveals genes that are specifically up- or down-regulated in each cluster relative to the overall population.

### Understanding the contrast matrix

A contrast is a linear combination of model coefficients that defines a specific comparison. For 7 clusters, we need 7 contrasts (one per cluster). Each contrast tests: "Is this cluster different from the average of all other clusters?"

Mathematically, if we want to compare cluster $k$ against the average of the other 6 clusters, the contrast weights are:

* Cluster $k$: weight = 1
* All other clusters: weight = $\frac{1}{1-7} = -\frac{1}{6}$

This ensures the contrast sums to zero (a requirement for valid hypothesis testing) and compares cluster $k$ to the mean of the remaining clusters.

The donor coefficients are set to 0 in the contrast because we're not interested in donor differences; we only want to test cluster effects while controlling for donor variation.

```{r contr}
ncls <- nlevels(cluster)
contr <- rbind( matrix(1/(1-ncls), ncls, ncls),
matrix(0, ncol(design)-ncls, ncls) )
diag(contr) <- 1
contr[1,] <- 0
rownames(contr) <- colnames(design)
colnames(contr) <- paste0("cluster", levels(cluster))
contr
```

In this matrix, each column represents one comparison.

## Differential expression testing

We perform a quasi-likelihood F-test for each contrast using `glmQLFTest()`. The quasi-likelihood F-test is preferred over the likelihood ratio test for bulk RNA-seq-like data because it accounts for uncertainty in dispersion estimation, providing better control of the false discovery rate when sample sizes are moderate.

```{r test_contrast}
qlf <- list()
for(i in 1:ncls){
  qlf[[i]] <- glmQLFTest(fit, contrast=contr[,i])
  qlf[[i]]$comparison <- paste0("cluster", levels(cluster)[i], "_vs_others")
}

length(qlf)
```

### Top differentially expressed genes

The `topTags()` function returns the most significant DE genes, sorted by p-value. Here are the top 10 genes distinguishing cluster 0 from all other clusters:

```{r top_tags_cluster0}
topTags(qlf[[1]], n=10L)
```

The output columns are:

* **logFC**: log2 fold change (positive = higher in cluster 0)
* **logCPM**: average log2 counts per million across all samples
* **F**: F-statistic from the quasi-likelihood test
* **PValue**: raw p-value
* **FDR**: false discovery rate (Benjamini-Hochberg adjusted p-value)

### Summary of DE genes across clusters

The `decideTests()` function classifies genes as significantly up-regulated (1), down-regulated (-1), or not significant (0) at FDR < 0.05. The table below shows how many genes fall into each category for each cluster comparison:

```{r de_summary}
dt <- lapply(lapply(qlf, decideTests), summary)
dt.all <- do.call("cbind", dt)
dt.all
```

The "Down" row indicates genes significantly lower in that cluster compared to others, while "Up" shows genes significantly higher. "NotSig" genes show no significant difference.

## Identifying cluster marker genes

To visualise cluster-specific expression patterns, we extract the top 20 up-regulated genes (positive logFC) from each cluster comparison. These represent potential marker genes that characterise each cell population.

```{r top_markers}
top <- 20
topMarkers <- list()
for(i in 1:ncls) {
  ord <- order(qlf[[i]]$table$PValue, decreasing=FALSE)
  up <- qlf[[i]]$table$logFC[ord] > 0
  topMarkers[[i]] <- rownames(y)[ord[up][1:top]]
}
topMarkers <- unique(unlist(topMarkers))
topMarkers
```

The combined list of unique marker genes across all clusters provides a gene set that should discriminate between cell populations.

## Heatmap visualisation

A heatmap of the marker genes allows us to visually confirm that these genes show cluster-specific expression patterns. We use log-transformed CPM values (log counts per million) to account for library size differences and apply row scaling (z-scores) to highlight relative expression patterns rather than absolute expression levels.

```{r heatmap}
lcpm <- edgeR::cpm(y, log=TRUE)
annot <- data.frame(cluster=paste0("cluster ", cluster))
rownames(annot) <- colnames(y)
ann_colors <- list(cluster=2:8)
names(ann_colors$cluster) <- paste0("cluster ", levels(cluster))
pheatmap::pheatmap(lcpm[topMarkers, ], breaks=seq(-2,2,length.out=101),
                   color=colorRampPalette(c("blue","white","red"))(100), scale="row",
                   cluster_cols=TRUE, border_color="NA", fontsize_row=5,
                   treeheight_row=70, treeheight_col=70, cutree_cols=7,
                   clustering_method="ward.D2", show_colnames=FALSE,
                   annotation_col=annot, annotation_colors=ann_colors)
```

In this heatmap:

* **Rows** represent marker genes, clustered by expression similarity
* **Columns** represent pseudobulk samples, clustered hierarchically and annotated by cell cluster
* **Colours** indicate relative expression (blue = low, red = high) after row-wise scaling
* The dendrogram is cut into 7 groups (`cutree_cols=7`) to highlight cluster separation

Genes that are good markers should show high expression (red) in their target cluster and low expression (blue) in other clusters.

## Session info

```{r}
#| label: session_info

sessionInfo()
```

Time taken to render notebook.

```{r}
#| label: notebook_runtime
end_time <- Sys.time()
end_time - start_time
```
