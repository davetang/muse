---
title: "4.10 Single cell RNA-seq differential expression with pseudobulking"
date: "`r Sys.Date()`"
output:
  workflowr::wflow_html:
    toc: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# https://stackoverflow.com/questions/30237310/setting-work-directory-in-knitr-using-opts-chunksetroot-dir-doesnt-wor
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
```

```{r load_libraries, include=FALSE}
suppressPackageStartupMessages({
  library(tidyverse)
  library(edgeR)
  library(Seurat)
  library(pheatmap)
})

options(mc.cores = 8)
```

```{r start_time, include=FALSE}
start_time <- Sys.time()
```

## Introduction

Performing differential expression (DE) analysis on scRNA-seq data presents unique challenges with the primary problem being that individual cells exhibit high variability.

**Pseudobulking** tries to address the issue of variability by aggregating counts from cells that share the same biological replicate (e.g., donor/sample) and cell type. This approach:

1. Reduces technical noise by averaging across many cells.
2. Properly accounts for biological replication at the sample level.
3. Allows the use of well-established bulk RNA-seq DE methods (e.g., edgeR) that have robust statistical frameworks.

This notebook demonstrates how to perform pseudobulk differential expression analysis using edgeR, following the workflow described in [Section 4.10 of the edgeR User's Guide](https://www.bioconductor.org/packages/release/bioc/vignettes/edgeR/inst/doc/edgeRUsersGuide.pdf).

## Data

The single cell RNA-seq data used in this notebook is from the human breast single cell RNA atlas generated by Pal et al. The preprocessing of the data and the complete bioinformatics analyses of the entire atlas study are described in detail in Chen et al. Most of the single cell analysis, such as dimensionality reduction and integration, were performed using Seurat. All the generated Seurat objects are publicly available on [Figshare](https://doi.org/10.6084/m9.figshare.17058077).

The Seurat object used in this notebook was downloaded directly from the website of the edgeR maintainers. This object contains breast tissue micro-environment samples from 13 individual healthy donors. This object has been subsetted to contain 10,000 cells of the total 24,751 cells from the original object.

```{r so}
so <- readRDS("data/SeuratObj.rds")
so
```

Distribution of cell counts across 13 healthy donors and 7 clusters; note that some samples don't have cells belonging to a certain cluster.

```{r group_versus_cluster}
table(so@meta.data$group, so@meta.data$seurat_clusters)
```

## Pseudobulking

Pseudo-bulk samples are created by aggregating read counts together for all the cells with the same combination of human donor and cluster. Here, we generate pseudo-bulk expression profiles from the Seurat object using the `Seurat2PB()` function. The human donor and cell cluster information of the integrated single cell data is stored in the `group` and `seurat_clusters` columns of the `meta.data` component of the Seurat object.

```{r y}
y <- Seurat2PB(so, sample="group", cluster="seurat_clusters")
dim(y$samples)
sum(table(so@meta.data$group, so@meta.data$seurat_clusters) > 0)
```

Counts are aggregated into samples + clusters; note that there aren't 13 * 7 samples because as we noted in the table, some combinations have 0 counts.

```{r y_counts}
colnames(y$counts)
```

The total UMI counts per pseudobulk sample vary considerably, reflecting differences in the number of cells aggregated and their sequencing depth. Importantly, the minimum is greater than zero, confirming that all sample-cluster combinations retained after aggregation contain actual expression data.

```{r y_counts_sum}
summary(colSums(y$counts))
```

## Filtering and normalisation

Before differential expression analysis, we apply two filtering steps to remove low-quality data that could compromise statistical inference.

### Sample filtering

Pseudobulk samples with very few total counts are unreliable because they may represent too few cells or low-quality aggregations. We remove samples with fewer than 50,000 total UMI counts.

```{r filter_samples}
keep.samples <- y$samples$lib.size > 5e4
y <- y[, keep.samples]

dim(y$samples)
```

### Gene filtering

Genes with very low counts across samples provide little statistical information and can adversely affect the multiple testing correction. The `filterByExpr()` function implements edgeR's recommended filtering strategy: it keeps genes that have sufficiently large counts to be statistically meaningful in at least some samples. By default, it requires a gene to have at least 10 counts (`min.count = 10`) in a minimum number of samples (determined by the smallest group size).

```{r filter_genes}
keep.genes <- filterByExpr(y, group=y$samples$cluster)
y <- y[keep.genes, , keep=FALSE]
```

### TMM normalisation

Trimmed Mean of M-values (TMM) normalisation corrects for compositional biases between samples. This is important because differences in library size alone don't account for situations where a few highly-expressed genes consume a disproportionate share of sequencing reads, making other genes appear artificially down-regulated. TMM calculates scaling factors that adjust for these composition effects.

```{r tmm}
y <- normLibSizes(y)
```

## Design matrix

To perform differential expression analysis between cell clusters, we create a design matrix that models both the biological effect of interest (cluster identity) and a blocking factor (donor). Including donor in the model accounts for individual-to-individual variation, ensuring that detected cluster differences are not confounded by donor-specific effects.

The formula `~ cluster + donor` creates an additive model where:

* **cluster** captures the differences between cell types (what we are interested in).
* **donor** accounts for baseline expression differences between individuals (a "nuisance" variable, as some people call it, we want to control for).

```{r design}
donor <- factor(y$samples$sample)
cluster <- as.factor(y$samples$cluster)
design <- model.matrix(~ cluster + donor)
colnames(design) <- gsub("donor", "", colnames(design))
colnames(design)[1] <- "Int"
dim(design)
```

The design matrix has 19 columns: 1 (intercept) + 6 (cluster coefficients, with cluster 0 as reference) + 12 (donor coefficients, with the first donor as reference) = 19 parameters to estimate. Each column represents one model coefficient.

The 59 rows correspond to the 59 pseudobulk samples (unique sample-cluster combinations that passed filtering).

```{r design_head}
head(design)
```

In the design matrix above, the first row represents a sample from cluster 0 and donor `N_0019_total`. It shows `Int=1` (the intercept) with all other coefficients as 0 because both the cluster and donor for this sample are the reference levels. Subsequent rows have 1s in the appropriate cluster and donor columns to indicate which combination each pseudobulk sample represents.

## Dispersion estimation and model fitting

RNA-seq count data exhibits overdispersion (variance exceeds the mean), which the negative binomial distribution models through a dispersion parameter. edgeR estimates dispersion using an empirical Bayes approach that shares information across genes, improving estimates especially when sample sizes are small.

The `robust=TRUE` option protects against outlier genes that might otherwise inflate dispersion estimates. The quasi-likelihood framework (`glmQLFit`) adds an additional layer of variance modelling that accounts for gene-specific variability beyond the negative binomial assumption, providing more reliable statistical inference.

```{r disp}
y <- estimateDisp(y, design, robust=TRUE)
fit <- glmQLFit(y, design, robust=TRUE)
```

## Contrast matrix for cluster comparisons

To identify marker genes for each cell cluster, we compare each cluster against all other clusters combined. This "one versus rest" approach reveals genes that are specifically up- or down-regulated in each cluster relative to the overall population.

### Understanding the contrast matrix

A contrast is a linear combination of model coefficients that defines a specific comparison. For 7 clusters, we need 7 contrasts (one per cluster). Each contrast tests: "Is this cluster different from the average of all other clusters?"

Mathematically, if we want to compare cluster $k$ against the average of the other 6 clusters, the contrast weights are:

* Cluster $k$: weight = 1
* All other clusters: weight = $\frac{1}{1-7} = -\frac{1}{6}$

This ensures the contrast sums to zero (a requirement for valid hypothesis testing) and compares cluster $k$ to the mean of the remaining clusters.

The donor coefficients are set to 0 in the contrast because we're not interested in donor differences; we only want to test cluster effects while controlling for donor variation.

```{r contr}
ncls <- nlevels(cluster)
contr <- rbind( matrix(1/(1-ncls), ncls, ncls),
matrix(0, ncol(design)-ncls, ncls) )
diag(contr) <- 1
contr[1,] <- 0
rownames(contr) <- colnames(design)
colnames(contr) <- paste0("cluster", levels(cluster))
contr
```

In this matrix, each column represents one comparison.

## Differential expression testing

We perform a quasi-likelihood F-test for each contrast using `glmQLFTest()`. The quasi-likelihood F-test is preferred over the likelihood ratio test for bulk RNA-seq-like data because it accounts for uncertainty in dispersion estimation, providing better control of the false discovery rate when sample sizes are moderate.

```{r test_contrast}
qlf <- list()
for(i in 1:ncls){
  qlf[[i]] <- glmQLFTest(fit, contrast=contr[,i])
  qlf[[i]]$comparison <- paste0("cluster", levels(cluster)[i], "_vs_others")
}

length(qlf)
```

### Top differentially expressed genes

The `topTags()` function returns the most significant DE genes, sorted by p-value. Here are the top 10 genes distinguishing cluster 0 from all other clusters:

```{r top_tags_cluster0}
topTags(qlf[[1]], n=10L)
```

The output columns are:

* **logFC**: log2 fold change (positive = higher in cluster 0)
* **logCPM**: average log2 counts per million across all samples
* **F**: F-statistic from the quasi-likelihood test
* **PValue**: raw p-value
* **FDR**: false discovery rate (Benjamini-Hochberg adjusted p-value)

### Summary of DE genes across clusters

The `decideTests()` function classifies genes as significantly up-regulated (1), down-regulated (-1), or not significant (0) at FDR < 0.05. The table below shows how many genes fall into each category for each cluster comparison:

```{r de_summary}
dt <- lapply(lapply(qlf, decideTests), summary)
dt.all <- do.call("cbind", dt)
dt.all
```

The "Down" row indicates genes significantly lower in that cluster compared to others, while "Up" shows genes significantly higher. "NotSig" genes show no significant difference.

## Identifying cluster marker genes

To visualise cluster-specific expression patterns, we extract the top 20 up-regulated genes (positive logFC) from each cluster comparison. These represent potential marker genes that characterise each cell population.

```{r top_markers}
top <- 20
topMarkers <- list()
for(i in 1:ncls) {
  ord <- order(qlf[[i]]$table$PValue, decreasing=FALSE)
  up <- qlf[[i]]$table$logFC[ord] > 0
  topMarkers[[i]] <- rownames(y)[ord[up][1:top]]
}
topMarkers <- unique(unlist(topMarkers))
topMarkers
```

The combined list of unique marker genes across all clusters provides a gene set that should discriminate between cell populations.

## Heatmap visualisation

A heatmap of the marker genes allows us to visually confirm that these genes show cluster-specific expression patterns. We use log-transformed CPM values (log counts per million) to account for library size differences and apply row scaling (z-scores) to highlight relative expression patterns rather than absolute expression levels.

```{r heatmap}
lcpm <- edgeR::cpm(y, log=TRUE)
annot <- data.frame(cluster=paste0("cluster ", cluster))
rownames(annot) <- colnames(y)
ann_colors <- list(cluster=2:8)
names(ann_colors$cluster) <- paste0("cluster ", levels(cluster))
pheatmap::pheatmap(lcpm[topMarkers, ], breaks=seq(-2,2,length.out=101),
                   color=colorRampPalette(c("blue","white","red"))(100), scale="row",
                   cluster_cols=TRUE, border_color="NA", fontsize_row=5,
                   treeheight_row=70, treeheight_col=70, cutree_cols=7,
                   clustering_method="ward.D2", show_colnames=FALSE,
                   annotation_col=annot, annotation_colors=ann_colors)
```

In this heatmap:

* **Rows** represent marker genes, clustered by expression similarity
* **Columns** represent pseudobulk samples, clustered hierarchically and annotated by cell cluster
* **Colours** indicate relative expression (blue = low, red = high) after row-wise scaling
* The dendrogram is cut into 7 groups (`cutree_cols=7`) to highlight cluster separation

Genes that are good markers should show high expression (red) in their target cluster and low expression (blue) in other clusters.

## Alternative parameterisation: Cell means model

The analysis above used a **treatment contrast model** (also called a reference level model), where the intercept represents the baseline group and other coefficients represent deviations from that baseline. An alternative is the **cell means model**, which directly estimates the mean expression for each group without an intercept.

The cell means model has several advantages:

1. **More intuitive contrasts**: Each coefficient directly represents a group mean, making it easier to specify comparisons like "cluster 0 vs cluster 1" or "cluster 0 vs average of all others".
2. **Symmetric treatment of groups**: No group is arbitrarily designated as the "reference" level.
3. **Clearer interpretation**: The design matrix directly shows which group each sample belongs to.

The key difference is in the formula:

* Treatment contrast: `~ cluster + donor` (includes intercept)
* Cell means: `~ 0 + cluster + donor` (no intercept, the `0 +` removes it)

Despite this different parameterisation, both models fit the same data and produce identical results when equivalent contrasts are specified.

### Analysis with a cell means model

Start from the Seurat object and with the same processing steps.

```{r cell_means_data}
y_cm <- Seurat2PB(so, sample="group", cluster="seurat_clusters")
keep.samples_cm <- y_cm$samples$lib.size > 5e4
y_cm <- y_cm[, keep.samples_cm]
keep.genes_cm <- filterByExpr(y_cm, group=y_cm$samples$cluster)
y_cm <- y_cm[keep.genes_cm, , keep=FALSE]
y_cm <- normLibSizes(y_cm)
```

### Cell means design matrix

The cell means model formula `~ 0 + cluster + donor` creates a design matrix where each cluster has its own column with a 1 indicating membership, rather than having an intercept with deviation coefficients.

```{r cell_means_design}
donor_cm <- factor(y_cm$samples$sample)
cluster_cm <- factor(y_cm$samples$cluster)

design_cm <- model.matrix(~ 0 + cluster_cm + donor_cm)
colnames(design_cm) <- gsub("cluster_cm", "cluster", colnames(design_cm))
colnames(design_cm) <- gsub("donor_cm", "", colnames(design_cm))
dim(design_cm)
```

The design matrix has 19 columns: 7 (one for each cluster) + 12 (donor coefficients) = 19 parameters. Note that this is the same total number of parameters as before; the intercept has been replaced by an additional cluster coefficient.

```{r cell_means_design_head}
head(design_cm)
```

Instead of an intercept column with 1s everywhere, we now have separate columns for each cluster.

Dispersion and model fitting

```{r cell_means_fit}
y_cm <- estimateDisp(y_cm, design_cm, robust=TRUE)
fit_cm <- glmQLFit(y_cm, design_cm, robust=TRUE)
```

### Constructing equivalent contrasts

Contrasts are more straightforward to specify with the cell means parameterisation. To compare cluster $k$ against the average of all other clusters, we simply assign:

* Cluster $k$: weight = 1
* All other clusters: weight = $-1/6$ (so they average to the comparison group)
* Donor coefficients: weight = 0 (not part of the comparison)

```{r cell_means_contrast}
ncls_cm <- nlevels(cluster_cm)
contr_cm <- matrix(0, nrow=ncol(design_cm), ncol=ncls_cm)
rownames(contr_cm) <- colnames(design_cm)
colnames(contr_cm) <- paste0("cluster", levels(cluster_cm))
for(i in 1:ncls_cm) {
  contr_cm[1:ncls_cm, i] <- -1/(ncls_cm - 1)
  contr_cm[i, i] <- 1
}
contr_cm
```

Each column clearly shows that the tested cluster gets weight 1 and all other clusters get weight $-1/6$, and donor effects are ignored (weight 0).

Differential expression testing with cell means model

```{r cell_means_test}
qlf_cm <- list()
for(i in 1:ncls_cm){
  qlf_cm[[i]] <- glmQLFTest(fit_cm, contrast=contr_cm[,i])
  qlf_cm[[i]]$comparison <- paste0("cluster", levels(cluster_cm)[i], "_vs_others")
}
```

### Comparing results: Treatment contrast vs Cell means

Verify that both parameterisations produce identical results by comparing the top DE genes for cluster 0 vs others.

```{r compare_top_genes}
top_tc <- topTags(qlf[[1]], n=10)$table
top_cm <- topTags(qlf_cm[[1]], n=10)$table
identical(rownames(top_tc), rownames(top_cm))
```

Compare the statistical values.

```{r compare_statistics}
comparison_df <- data.frame(
  Gene = rownames(top_tc),
  logFC_treatment = round(top_tc$logFC, 6),
  logFC_cellmeans = round(top_cm$logFC, 6),
  FDR_treatment = signif(top_tc$FDR, 6),
  FDR_cellmeans = signif(top_cm$FDR, 6)
)
comparison_df
```

Compare all logFC values.

```{r compare_all_logfc}
all_tc <- qlf[[1]]$table
all_cm <- qlf_cm[[1]]$table

# Ensure same gene order
all_cm <- all_cm[rownames(all_tc), ]

# Check correlation and maximum difference
cat("Correlation of logFC values:", cor(all_tc$logFC, all_cm$logFC), "\n")
cat("Maximum absolute difference in logFC:", max(abs(all_tc$logFC - all_cm$logFC)), "\n")
cat("Maximum absolute difference in PValue:", max(abs(all_tc$PValue - all_cm$PValue)), "\n")
```

The results are identical (within numerical precision), confirming that both parameterisations are mathematically equivalent. The choice between them is a matter of convenience and interpretability:

* **Treatment contrasts** are the R default and work well when you have a natural reference group.
* **Cell means models** make it easier to specify arbitrary contrasts and may be more intuitive for complex comparisons.

### Summary of DE genes comparison

```{r compare_de_summary}
dt_cm <- lapply(lapply(qlf_cm, decideTests), summary)
dt_cm.all <- do.call("cbind", dt_cm)

cat("Treatment contrast model:\n")
print(dt.all)

cat("\nCell means model:\n")
print(dt_cm.all)

cat("\nDifference (should be all zeros):\n")
print(dt.all - dt_cm.all)
```

The identical number of DE genes in each category confirms that both approaches yield the same biological conclusions.

## Session info

```{r}
#| label: session_info

sessionInfo()
```

Time taken to render notebook.

```{r}
#| label: notebook_runtime
end_time <- Sys.time()
end_time - start_time
```
