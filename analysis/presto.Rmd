---
title: "Checking out the presto package"
date: "`r Sys.Date()`"
output:
  workflowr::wflow_html:
    toc: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# https://stackoverflow.com/questions/30237310/setting-work-directory-in-knitr-using-opts-chunksetroot-dir-doesnt-wor
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
```

[Presto scales Wilcoxon and auROC analyses to millions of observations](https://www.biorxiv.org/content/10.1101/653253v1)

> The related Wilcoxon rank sum test and area under the receiver operator curve are ubiquitous in high dimensional biological data analysis. Current implementations do not scale readily to the increasingly large datasets generated by novel high-throughput technologies, such as single cell RNAseq. We introduce a simple and scalable implementation of both analyses, available through the R package Presto. Presto scales to big datasets, with functions optimized for both dense and sparse matrices. On a sparse dataset of 1 million observations, 10 groups, and 1,000 features, Presto performed both rank-sum and auROC analyses in only 17 seconds, compared to 6.4 hours with base R functions. Presto also includes functions to seamlessly integrate with the Seurat single cell analysis pipeline and the Bioconductor SingleCellExperiment class. Presto enables the use of robust classical analyses on big data with a simple interface and optimized implementation.

Install the following packages, if necessary.

```{r install_presto, eval=FALSE}
remotes::install_github("immunogenomics/presto")
```

Load {presto}.

```{r load_presto}
suppressPackageStartupMessages(library("presto"))
suppressPackageStartupMessages(library("Seurat"))
```

## Seurat object

Import [raw pbmc3k dataset](pbmc3k.html) from my server.

```{r seurat_obj}
seurat_obj <- readRDS(url("https://davetang.org/file/pbmc3k_seurat.rds", "rb"))
seurat_obj
```

Filter.

```{r pbmc3k}
pbmc3k <- CreateSeuratObject(
  counts = seurat_obj@assays$RNA$counts,
  min.cells = 3,
  min.features = 200,
  project = "pbmc3k"
)
pbmc3k
```
Normalise.

```{r normalise_data}
seurat_obj <- NormalizeData(seurat_obj, normalization.method = "LogNormalize", scale.factor = 1e4, verbose = FALSE)
```

## Wilcoxon Rank Sum

Calculate gene variance and use gene with the highest variance for our testing.

```{r gene_var}
gene_var <- apply(seurat_obj@assays$RNA$data, 1, var)
head(sort(gene_var, decreasing = TRUE))
```

Get the gene expression.

```{r gene_exp}
my_gene <- names(head(sort(gene_var, decreasing = TRUE), 1))
gene_exp <- seurat_obj@assays$RNA$data[my_gene, ]
head(gene_exp)
```

Create two (random) groups.

```{r random_groups}
ngenes <- length(gene_exp)
set.seed(1984)
g1 <- sample(names(gene_exp), ngenes/2)
g2 <- setdiff(names(gene_exp), g1)
stopifnot(length(unique(c(g1, g2))) == ngenes)
```

Plot expression.

```{r plot_exp}
x <- gene_exp[g1]
y <- gene_exp[g2]

my_df <- data.frame(
  barcode = c(g1, g2),
  group = c(rep('g1', ngenes/2), rep('g2', ngenes/2)),
  exp = c(x, y)
)

boxplot(
  exp~group,
  data = my_df,
  main = my_gene
)
```

Perform Wilcoxon Rank Sum and Signed Rank Tests using `wilcox.test`.

```{r wilcox_test}
res <- wilcox.test(exp~group, data = my_df)
res
```

Fast Wilcoxon rank sum test and auROC using `presto::wilcoxauc()`.

```{r run_presto_wilcox}
my_mat <- matrix(my_df$exp, nrow = 1)
colnames(my_mat) <- my_df$barcode
rownames(my_mat) <- my_gene
y <- factor(my_df$group)
presto_res <- wilcoxauc(my_mat, y)
presto_res
```

Compare p-values.

```{r compare_pval}
res$p.value == presto_res$pval[1]
```

Average expression.

```{r avg_expr}
my_df |>
  dplyr::summarise(avgExpr = mean(exp), .by = group)
```

Log fold change.

```{r logfc}
my_df |>
  dplyr::summarise(avgExpr = mean(exp), .by = group) |>
  dplyr::summarise(across(avgExpr, ~ log(.x[1] / .x[2])))
```

The difference between logFC calculations is a [known issue](https://github.com/immunogenomics/presto/issues/6); use the fix suggested by [slowkow](https://github.com/immunogenomics/presto/issues/6#issuecomment-1879176030).

```{r wilcoxauc_mod}
wilcoxauc_mod <- function(X, y, groups_use = NULL, verbose = TRUE, ...) {
    ## Check and possibly correct input values
    if (is(X, "dgeMatrix")) X <- as.matrix(X)
    if (is(X, "data.frame")) X <- as.matrix(X)
    if (is(X, "dgTMatrix")) X <- as(X, "dgCMatrix")
    if (is(X, "TsparseMatrix")) X <- as(X, "dgCMatrix")
    if (ncol(X) != length(y)) stop("number of columns of X does not
                                match length of y")
    if (!is.null(groups_use)) {
        idx_use <- which(y %in% intersect(groups_use, y))
        y <- y[idx_use]
        X <- X[, idx_use]
    }

    y <- factor(y)
    idx_use <- which(!is.na(y))
    if (length(idx_use) < length(y)) {
        y <- y[idx_use]
        X <- X[, idx_use]
        if (verbose)
            message("Removing NA values from labels")
    }

    group.size <- as.numeric(table(y))
    if (length(group.size[group.size > 0]) < 2) {
        stop("Must have at least 2 groups defined.")
    }

    if (is.null(row.names(X))) {
        row.names(X) <- paste0("Feature", seq_len(nrow(X)))
    }

    ## Compute primary statistics
    group.size <- as.numeric(table(y))
    n1n2 <- group.size * (ncol(X) - group.size)
    if (is(X, "dgCMatrix")) {
        rank_res <- rank_matrix(Matrix::t(X))
    } else {
        rank_res <- rank_matrix(X)
    }

    ustat <- presto:::compute_ustat(rank_res$X_ranked, y, n1n2, group.size)
    auc <- t(ustat / n1n2)
    pvals <- presto:::compute_pval(ustat, rank_res$ties, ncol(X), n1n2)
    fdr <- apply(pvals, 2, function(x) p.adjust(x, "BH"))

    ### Auxiliary Statistics (AvgExpr, PctIn, LFC, etc)
    group_sums <- sumGroups(X, y, 1)
    group_nnz <- nnzeroGroups(X, y, 1)
    group_pct <- sweep(group_nnz, 1, as.numeric(table(y)), "/") %>% t()
    group_pct_out <- -group_nnz %>%
        sweep(2, colSums(group_nnz) , "+") %>% 
        sweep(1, as.numeric(length(y) - table(y)), "/") %>% t()
    group_means <- sweep(group_sums, 1, as.numeric(table(y)), "/") %>% t()
    cs <- colSums(group_sums)
    gs <- as.numeric(table(y))
    lfc <- Reduce(cbind, lapply(seq_len(length(levels(y))), function(g) {
        group_means[, g] / ((cs - group_sums[g, ]) / (length(y) - gs[g]))
    })) |> log()

    res_list <- list(auc = auc,
                pval = pvals,
                padj = fdr,
                pct_in = 100 * group_pct,
                pct_out = 100 * group_pct_out,
                avgExpr = group_means,
                statistic = t(ustat),
                logFC = lfc)
    return(presto:::tidy_results(res_list, row.names(X), levels(y)))
}

assignInNamespace("wilcoxauc.default", wilcoxauc_mod, ns = "presto")

wilcoxauc(my_mat, y)
```
